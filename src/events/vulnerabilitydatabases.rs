/*
 * (c) 2021 QVLX LLC. All rights reserved.
 *
 * !! WARNING !!
 * THIS DOCUMENT CONTAINS CONFIDENTIAL AND PROPRIETARY DATA ORIGINATED BY QVLX LLC.
 * ALL DESIGN, MANUFACTURING PRODUCTION, USE, SALE AND PATENT RIGHTS ARE EXPRESSLY RESERVED.
 *
 * THE DATA CONTAINED IN THIS DOCUMENT IS SUBJECT TO ITAR/EAR RESTRICTIONS.
 *
 * THE RECIPIENT AGREES BY VIEWING THIS DOCUMENT NOT TO SUPPLY OR DISCLOSE ANY INFORMATION
 * REGARDING IT TO UNAUTHORIZED PERSONS OR INCORPORATE INTO ANY OTHER DESIGN OR USE THEREOF.
 *
 * VIOLATION OF THESE TERMS WILL BE SUBJECT TO PROSECUTION AT THE FULL EXTENT OF THE LAW.
 */

/*
 * QVLx Salvum 
 *
 * packetsniffers.rs
 *
 * authors: $t@$h, r00r00, n3wmAn
 */
use crate::events::*;
/*********************************** Vulnerability Databases ***********************************/
pub struct VulnerabilityDatabases { event: Event }
impl Eventable for VulnerabilityDatabases {
  fn on_init(&self) -> Vec<String> {
    print::println("Vulnerability Databases");
    return Vec::new();
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn vulnerabilitydatabases(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(VulnerabilityDatabases {
    event: Event {
      name:   name,
      desc:   "Vulnerability Databases".to_string(),
      usage:  "".to_string(),
      parent: parent,
      author: "".to_string(),
      easyrun: false,
      secure: false,
      links:  links
    }
  })
}

/*********************************** CVE ***********************************/
pub struct CVE { event: Event }
impl Eventable for CVE {
  fn on_init(&self) -> Vec<String> {
    let substring = prompt_in_event!("CVE>", "Enter CVE number to search: ");
    return vec![substring];
  }
	fn on_run(&self, args: Vec<String>) -> String {
		if !args.len() == 1 { return self.event.usage.clone(); }
    let substring = args[0].clone();
    let arguments = vec!["ext/util/cve.xml".to_string(), substring];
 
    // Run command
    let output = match run_console_command(Command::new("ext/cve/cve").args(&arguments)) {
      Ok(o) => o,
      Err(err) => { return format!("failed to execute cve check. {}\n", err); }   
    };
    return String::from_utf8_lossy(&output.stdout).to_string();
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/cve/atf/atf.txt";
    let cve_args = vec!["ext/util/cve.xml", "CVE-2014-0160"];

    // Run command
    let output = match Command::new("ext/cve/cve").args(cve_args).output() {
      Ok(o) => o,
      Err(err) => {
        debug::print_debug(format!("Error with cve search: {}", err));
        return TestStatus::Failed;
      }
    };

    // Read artifact file
    let atf_str = match fs::read_to_string(artifact_path) {
      Ok(out) => out,
      Err(err) => {
        debug::print_debug(format!("cve::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };

    // Compare
    if String::from_utf8_lossy(&output.stdout) != atf_str { return TestStatus::Failed; }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn cve(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(CVE {
    event: Event {
      name:   name,
      desc:   "Common Vulnerabilites and Exposures Database search.".to_string(),
      usage:  "This database querying application takes one argument: an entry to search\n\nExample: cve CVE-2019-0708\n".to_string(),
      parent: parent,
      author: "$t@$h and Mitre Corporation (https://cve.mitre.org/)".to_string(),
      easyrun: false,
      secure: false,
      links:  links
    }
  })
}

/*********************************** RCVE ***********************************/
pub struct RCVE { event: Event }
impl Eventable for RCVE {
  fn on_init(&self) -> Vec<String> {
    let substring = prompt_in_event!("RCVE>", "Enter reverse search substring: ");
    return vec![substring];
  }
	fn on_run(&self, args: Vec<String>) -> String {
		if !args.len() == 1 { return self.event.usage.clone(); }
    let f_c_arg = "f";
    let substring = args[0].clone();
    let arguments = vec!["ext/util/cve.xml".to_string(), substring, f_c_arg.to_string()];
 
    // Run command
    let output = match run_console_command(Command::new("ext/rcve/slm_rcve").args(&arguments)) {
      Ok(o) => o,
      Err(err) => { return format!("failed to execute rcve search. {}\n", err); }   
    };
    return String::from_utf8_lossy(&output.stdout).to_string();
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/rcve/atf/atf.txt";
    let cve_args = vec!["ext/util/cve.xml", "Xbox", "c"];

    // Run command
    let output = match Command::new("ext/rcve/slm_rcve").args(cve_args).output() {
      Ok(o) => o,
      Err(err) => {
        debug::print_debug(format!("Error: {}", err));
        return TestStatus::Failed;
      }
    };

    // Read artifact file
    let atf_str = match fs::read_to_string(artifact_path) {
      Ok(out) => out,
      Err(err) => {
        debug::print_debug(format!("rcve::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };

    // Compare
    if String::from_utf8_lossy(&output.stdout) != atf_str { return TestStatus::Failed; }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn rcve(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(RCVE {
    event: Event {
      name:   name,
      desc:   "Reverse Common Vulnerabilites and Exposures Database search.".to_string(),
      usage:  "This database querying application takes one argument: a string to search\n".to_string(),
      parent: parent,
      author: "$t@$h and Mitre Corporation (https://cve.mitre.org/)".to_string(),
      easyrun: false,
      secure: false,
      links:  links
    }
  })
}

/*********************************** ExploitDB ***********************************/
pub struct ExploitDB { event: Event }
impl Eventable for ExploitDB {
  fn on_init(&self) -> Vec<String> {
    let substring = prompt_in_event!("ExploitDB>", "Enter substring to search in ExploitDB: ");
    return vec![substring];
  }
	fn on_run(&self, args: Vec<String>) -> String {
	  if !args.len() == 1 { return self.event.usage.clone(); }
    // Run command
    let output = match run_command(Command::new("ext/exploitdb/searchsploit").arg(args[0].clone())) {
      Ok(o) => o,
      Err(err) => { return format!("failed to execute searchsploit. {}\n", err); }
    };
    let mut outname = String::from("out/exploitdb/");
    outname.push_str(&args[0].replace(".","").replace("/",""));
    outname.push_str("_exploitdb.txt");
    util::misc::write_file((&String::from_utf8_lossy(&output.stdout)).to_string(),outname.clone());
    let mut msg = String::from("Results written to: ");
    msg.push_str(&outname);
    print::print_custom(&format!("{}\n",&msg),"orange");
    return format!("{}", &String::from_utf8_lossy(&output.stdout));
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/exploitdb/atf/atf.txt";

    // Run command
    let output = match Command::new("ext/exploitdb/searchsploit").arg("ipad").output() {
      Ok(o) => o,
      Err(err) => {
        debug::print_debug(format!("Error testing exploitdb: {}", err));
        return TestStatus::Failed;
      }
    };
    let out_str = String::from_utf8_lossy(&output.stdout);

    // Read artifact file
    let atf_str = match fs::read_to_string(artifact_path) {
      Ok(out) => out,
      Err(err) => {
        debug::print_debug(format!("exploitdb::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };

    // Compare
    let out_lines: Vec<&str> = out_str.split("\n").collect();
    let atf_lines: Vec<&str> = atf_str.split("\n").collect();
    if out_lines.len() != atf_lines.len() {
      debug::print_debug(format!("-- Output --\n{}\n-- Artifact --\n{}", String::from_utf8_lossy(&output.stdout), atf_str));
      return TestStatus::Failed;
    }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn exploitdb(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(ExploitDB {
    event: Event {
      name:   name,
      desc:   "The well known Exploit Database.".to_string(),
      usage:  "This database querying application takes one argument: a string to search\n".to_string(),
      parent: parent,
      author: "Offensive Security\n\nhttps://www.offensive-security.com/".to_string(),
      easyrun: false,
      secure: false,
      links:  links
    }
  })
}

/*********************************** BruteforceDB ***********************************/
pub struct BruteforceDB { event: Event }
impl Eventable for BruteforceDB {
  fn on_init(&self) -> Vec<String> {
    let substring = prompt_in_event!("BruteforceDB>", "Enter password to search in BruteforceDB: ");
    return vec![substring];
  }
	fn on_run(&self, args: Vec<String>) -> String {
		if args.len() !=  1 { return self.event.usage.clone(); }
    let out = simple_match!(run_console_command(Command::new("ext/bruteforcedb/locate")
									 .args(vec!["-c","-p","ext/bruteforcedb/bruteforce-database","-q",&args[0]])));
		let mut outname = String::from("out/bruteforcedb/");
		outname.push_str(&args[0]);
		outname.push_str("_bruteforcedb.txt");
    let output = simple_match!(Command::new("ext/bruteforcedb/locate")
									 .args(vec!["-c","-p","ext/bruteforcedb/bruteforce-database","-q",&args[0]]).output());
		util::misc::write_file(String::from_utf8_lossy(&output.stdout).to_string(),outname.clone());
		let mut msg = String::from("Results written to: ");
		msg.push_str(&outname);
		print::print_custom(&format!("{}\n",&msg),"lightorange");
	  return String::from_utf8_lossy(&out.stdout).to_string();
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/bruteforcedb/atf/atf.txt";
    let cve_args = vec!["-c","-p","ext/bruteforcedb/bruteforce-database","-q","ghost12"];

    // Run command
    let output = match Command::new("ext/bruteforcedb/locate").args(cve_args).output() {
      Ok(o) => o,
      Err(err) => {
        debug::print_debug(format!("Error testing bruteforcedb: {}", err));
        return TestStatus::Failed;
      }
    };

    // Read artifact file
    let atf_str = match fs::read_to_string(artifact_path) {
      Ok(out) => out,
      Err(err) => {
        debug::print_debug(format!("bruteforcedb::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };

    // Compare
    let out_str = String::from_utf8_lossy(&output.stdout);

    let out_lines: Vec<&str> = out_str.split("\n").collect();
    let atf_lines: Vec<&str> = atf_str.split("\n").collect();

    if out_lines.len() != atf_lines.len() { 
      debug::print_debug(format!("output:\n{}\natf:\n{}",out_str,atf_str));
      return TestStatus::Failed; 
    }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn bruteforcedb(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(BruteforceDB {
    event: Event {
      name:   name,
      desc:   "BruteforceDB Aggregated Password Database.".to_string(),
      usage:  "This database querying application takes one argument: password to search\n".to_string(),
      parent: parent,
      author: "Duyet Le\tme@duyet.net".to_string(),
      easyrun: false,
      secure: false,
      links:  links
    }
  })
}

/*********************************** FCC ***********************************/
pub struct FCC { event: Event }
impl Eventable for FCC {
  fn on_init(&self) -> Vec<String> {
    let substring = prompt_in_event!("FCC>", "Enter the substring or FCC ID to search: ");
    return vec![substring];
  }
	fn on_run(&self, args: Vec<String>) -> String {
		if !args.len() == 1 { return self.event.usage.clone(); }
 
    // Run command
    let output = match run_console_command(Command::new("ext/fcc/fcc_search").args(vec!["ext/fcc/fcc_db",&args[0]])) {
      Ok(o) => o,
      Err(err) => { return format!("failed to execute fcc check. {}\n", err); }   
    };
    return String::from_utf8_lossy(&output.stdout).to_string();
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/fcc/atf/atf.txt";

    // Run command
    let output = match Command::new("ext/fcc/fcc_search").args(vec!["ext/fcc/fcc_db","__TEST__"]).output() {
      Ok(o) => o,
      Err(err) => {
        debug::print_debug(format!("Error: {}", err));
        return TestStatus::Failed;
      }
    };

    // Read artifact file
    let atf_str = match fs::read_to_string(artifact_path) {
      Ok(out) => out,
      Err(err) => {
        debug::print_debug(format!("fcc::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };

    // Compare
    if String::from_utf8_lossy(&output.stdout) != atf_str { return TestStatus::Failed; }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn fcc(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(FCC {
    event: Event {
      name:   name,
      desc:   "FCC ID Database.".to_string(),
      usage:  "App takes one argument: a string to search\n".to_string(),
      parent: parent,
      author: "$t@$h and the FCC".to_string(),
      easyrun: false,
      secure: false,
      links:  links
    }
  })
}
