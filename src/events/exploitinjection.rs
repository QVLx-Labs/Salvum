/*
 * QVLx Salvum 
 *
 * exploitinjection.rs
 *
 * authors: $t@$h, r00r00, n3wmAn
 */
use crate::events::*;

  
/*********************************** EXPLOIT INJECTION ***********************************/
pub struct ExploitInjection { event: Event }
impl Eventable for ExploitInjection {
  fn on_init(&self) -> Vec<String> {
    print::println("Exploit Injection");
    return Vec::new();
  } 
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn exploitinjection(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(ExploitInjection {
    event: Event {
      name:   name,
      desc:   "Exploit injection tools".to_string(),
      usage:  "".to_string(),
      author: "".to_string(),
      easyrun: false,
      secure: false,
      parent: parent,
      links:  links
    }
  })
}

/*********************************** Metasploit ***********************************/
pub struct Metasploit { event: Event }
impl Eventable for Metasploit {
  fn on_init(&self) -> Vec<String> {
    return Vec::new();
  }
  fn on_run(&self, _args: Vec<String>) -> String {
    let mut dir_path = String::from("ext/metasploit");
    util::misc::reltoabs(&mut dir_path);
    simple_match!(Command::new("git").args(vec!["config","--global","--add","safe.directory",&dir_path]).output());
    let output = simple_match!(run_console_command(Command::new("ruby").args(vec!["-W0",
                                                                                  "ext/metasploit/msfconsole",
                                                                                  "-q",
                                                                                  "-n",
                                                                                  "--defer-module-loads"])));

    // Print output
    log::log("Metasploit", &String::from_utf8_lossy(&output.stderr));
    return String::from_utf8_lossy(&output.stdout).to_string();
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/metasploit/atf/atf.txt";

    // git config --global --add safe.directory /home/shared/slm/ext/metasploit
    let mut dir_path = String::from("ext/metasploit");
    util::misc::reltoabs(&mut dir_path);
    simple_test_match!(Command::new("git").args(vec!["config","--global","--add","safe.directory",&dir_path]).output());
    let check = simple_test_match!(Command::new("ext/metasploit/msfconsole").arg("-v").output());

    // Read file
    let file_str = simple_test_match!(fs::read_to_string(artifact_path));

    let output_str_utf8 = String::from_utf8_lossy(&check.stderr);
    let output_tkns_colon = output_str_utf8.split(":").collect::<Vec<&str>>();

    // Compare
    if output_tkns_colon[0] != file_str {
      debug::print_debug(&format!("output: {}\nartifact: {}\n",output_str_utf8,file_str));
      debug::print_debug("output does not match artifact");
      return TestStatus::Failed;
    }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn metasploit(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync>  {
  Box::new(Metasploit {
    event: Event {
      name:   name,
      desc:   "Comprehensive exploitation engine.".to_string(),
      usage:  "Simply invoke metasploit to open the console\n".to_string(),
      author: "Metasploit Project".to_string(),
      easyrun: false,
      secure: false,
      parent: parent,
      links:  links
    }
  })
}

/*********************************** Routersploit ***********************************/
pub struct Routersploit { event: Event }
impl Eventable for Routersploit {
  fn on_init(&self) -> Vec<String> {
    let output = match run_console_command(Command::new("python3").args(vec!["ext/routersploit/rsf.py"])) {
      Ok(out) => out,
      Err(err) => {
        println!("Error: {}", err);
        return Vec::new();
      }
    };
    // Print output
    print!("{}", String::from_utf8_lossy(&output.stdout));
    log::log("Routersploit", &String::from_utf8_lossy(&output.stderr));
    util::misc::cleanup("routersploit.log");
    return Vec::new();
  }
  fn on_test(&self) -> TestStatus {
    let artifact_path = "tst/routersploit/atf/atf.txt";

    let check = match Command::new("python3").args(vec!["ext/routersploit/rsf.py","-h"]).output() {
      Ok(c) => c,
      Err(err) => {
        debug::print_debug(format!("routersploit::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };
    util::misc::cleanup("routersploit.log");

    // Read file
    let file_str = match fs::read_to_string(artifact_path) {
      Ok(out) => out,
      Err(err) => {
        debug::print_debug(format!("routersploit::on_test: Failed to open the test file. {}", err));
        return TestStatus::Failed;
      }
    };

    let output = String::from_utf8_lossy(&check.stdout);

    // Compare
    if output != file_str {
      return TestStatus::Failed;
    }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn routersploit(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync>  {
  Box::new(Routersploit {
    event: Event {
      name:   name,
      desc:   "Embedded systems exploitation engine.".to_string(),
      usage:  "Simply invoke 'routersploit' to start using\n".to_string(),
      author: "threat9.com".to_string(),
      easyrun: false,
      secure: false,
      parent: parent,
      links:  links
    }
  })
}

/*********************************** FirmwareModkit ***********************************/
pub struct FirmwareModkit { event: Event }
impl Eventable for FirmwareModkit {
  fn on_init(&self) -> Vec<String> {
    print::println("Firmware modkit tools");
    return Vec::new();
  } 
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn firmwaremodkit(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(FirmwareModkit {
    event: Event {
      name:   name,
      desc:   "Collection of scripts and utilities to extract and rebuild Linux firmware images.".to_string(),
      usage:  "".to_string(),
      author: "".to_string(),
      easyrun: false,
      secure: false,
      parent: parent,
      links:  links
    }
  })
}

/*********************************** FIRMEXTRACT ***********************************/
pub struct FirmExtract { event: Event }
impl Eventable for FirmExtract {
  fn on_init(&self) -> Vec<String> {
    
    //prompt for path to firmware
    let mut firm_path = prompt_in_event!("FirmExtract>", "Path: ");
      //check for existence
    if !Path::new(&firm_path).exists() {
      print::println(&format!("Firmware path does not exist: {}",firm_path));
      return Vec::new();
    }

    //convert rel path to absolute
    util::misc::reltoabs(&mut firm_path);
    
    //get the current working path
    let current_path = match env::current_dir() {
      Ok(dir) => dir,
      Err(err) => {
        println!("Something bad happened {}",err);
        return Vec::new();
      }
    };
    
    //prompt for path to output dir
    let mut output_path = current_path.to_string_lossy().to_string();
    let dt = chrono::offset::Local::now(); //create the DateTime pub struct
    let datetime: String = str::replace(&dt.to_string()," ","_"); //convert to a string and replace any ' ' with '_'
    let datetime: String = str::replace(&datetime,":","-");
    output_path.push_str("/out/firmware/fmk_");
    output_path.push_str(&datetime[..19]);


    //change working directory to files/firmware-mod-kit
    //the fmk scripts won't work right with relative paths. therefore an absolute path must be fetched.
    //first get current path, then append with relative path to firmware mod kit to get the absolute path
    let mut fmk_path: String = current_path.to_string_lossy().to_string();
    fmk_path.push_str("/ext/firmware-mod-kit"); //append the relative path

    //execute extraction script
    let args = vec![firm_path,output_path.clone()];
    match run_console_command(Command::new("./extract-firmware.sh").args(args).current_dir(fmk_path.clone())) {
      Ok(_) => {},
      Err(err) => {
        print::println(&format!("Failed to execute extraction script. Error: {}",err));
      }
    }

    //verify that extraction dir exists
    if Path::new(&output_path).exists() {
      print::println(&format!("Firmware extracted successfully. Files placed in: {}", output_path));
    }
    else {
      print::println(&format!("Failed to extract firmware. Files not placed in: {}", output_path));
    }
    return Vec::new();
  }
  fn on_test(&self) -> TestStatus {
    let fmk_path = "ext/firmware-mod-kit";
    let mut tests = vec![
      vec!["../../tst/firmextract/inp/firmware.bin","../../tst/firmextract/out/extracted","tst/firmextract/out/extracted/image_parts/header.img","tst/firmextract/atf/extracted/image_parts/header.img"],
      vec!["../../tst/firmextract/inp/firmware.bin","../../tst/firmextract/out/extracted","tst/firmextract/out/extracted/image_parts/rootfs.img","tst/firmextract/atf/extracted/image_parts/rootfs.img"]
    ];
    for test in &mut tests {
      //grab artifact path from test vector
      let artifact_path_str = match test.pop() {
        Some(string) => string,
        None => {
          debug::print_debug("firmextract::on_test: invalid test vector");
          return TestStatus::Failed;
        }
      };
      let artifact_path = Path::new(artifact_path_str);

      //grab output path from test vector
      let output_path_str = match test.pop() {
        Some(string) => string,
        None => {
          debug::print_debug("firmextract::on_test: invalid test vector");
          return TestStatus::Failed;
        }
      };
      let output_path = Path::new(output_path_str);
      
      //make sure that the output path is clean
      //clean up the extracted dir from out
      //rm -rf tst/firmextract/out/extracted
      if Path::new("tst/firmextract/out/extracted").exists() {
        match Command::new("rm").args(vec!["-rf","tst/firmextract/out/extracted"]).output() {
          Ok(_) => {},
          Err(err) => {
            debug::print_debug(format!("firmextract::on_test: failed to clean up out dir. {}",err));
            return TestStatus::Failed;
          }
        };
      }
      
      //run firmware extract in fmk_path
      let command = "./extract-firmware.sh";
      let output = match Command::new(command).args(test).current_dir(fmk_path).output() {
        Ok(out) => out,
        Err(err) => {
          debug::print_debug(format!("firmextract::on_test: failed to execute firmextract. {}",err));
          return TestStatus::Failed;
        }
      };

      //make sure that firmextract returned with an exit code of 0
      let exit_status = match output.status.code() {
        Some(status) => status,
        None => {
          debug::print_debug("firmextract::on_test: failed to get firmextract exit code.");
          return TestStatus::Failed;
        }
      };
      if exit_status != 0 {
        debug::print_debug("firmextract::on_test: firmextract returned with a non-zero exit code");
        return TestStatus::Failed;
      }

      //read artifact file to byte vec
      let artifact_vec: Vec<u8> = match fs::read(artifact_path) {
        Ok(vec) => vec,
        Err(err) => {
          debug::print_debug(format!("firmextract::on_test: failed to read artifact file to byte vec {}",err));
          return TestStatus::Failed;
        }
      };

      //read output file to byte vec
      let output_vec: Vec<u8> = match fs::read(output_path) {
        Ok(vec) => vec,
        Err(err) => {
          debug::print_debug(format!("firmextract::on_test: failed to read output file to byte vec {}",err));
          return TestStatus::Failed;
        }
      };

      //compare the output file to the artifact file
      if artifact_vec != output_vec {
        debug::print_debug("firmextract::on_test: output vec doesnt match artifact vec.");
        return TestStatus::Failed;
      }
    }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn firmextract(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(FirmExtract {
    event: Event {
      name:   name,
      desc:   "Firmware extraction on images with uImage/TRX headers and SquashFS or CramFS.".to_string(),
      usage:  "Prompts you for: \
              \n\tPath to firmware\n".to_string(),
      author: "github.com/rampageX".to_string(),
      easyrun: false,
      secure: false,
      parent: parent,
      links:  links
    }
  })
}

/*********************************** FIRMREBUILD ***********************************/
pub struct FirmRebuild { event: Event }
impl Eventable for FirmRebuild {
  fn on_init(&self) -> Vec<String> {
    let mut build_path = prompt_in_event!("FirmRebuild>","Path: ");

    util::misc::reltoabs(&mut build_path);

    //get the current working path
    let current_path = match env::current_dir() {
      Ok(dir) => dir,
      Err(err) => {
        println!("Something bad happened {}",err);
        return Vec::new();
      }
    };
    
    //change working directory to files/firmware-mod-kit
    //the fmk scripts won't work right with relative paths. therefore an absolute path must be fetched.
    //first get current path, then append with relative path to firmware mod kit to get the absolute path
    let mut fmk_path: String = current_path.to_string_lossy().to_string();
    fmk_path.push_str("/ext/firmware-mod-kit"); //append the relative path

    //execute rebuild script
    let args = vec![build_path.clone()];
    match run_console_command(Command::new("./build-firmware.sh").args(args).current_dir(fmk_path.clone())) {
      Ok(_) => {},
      Err(err) => {
        print::println(&format!("Failed to execute rebuild script. Error: {}",err));
      }
    }

    //verify that extraction dir exists
    if Path::new(&build_path).exists() {
      print::println(&format!("Firmware built successfully. Files placed in: {}", build_path));
    }
    else {
      print::println(&format!("Failed to build firmware. Files NOT placed in: {}", build_path));
    }
    return Vec::new();
  }
  fn on_test(&self) -> TestStatus {
    let fmk_path = "ext/firmware-mod-kit";
    let mut tests = vec![
      vec!["../../tst/firmrebuild/inp/extracted","tst/firmrebuild/inp/extracted/new-firmware.bin","tst/firmrebuild/atf/new-firmware.bin"]
    ];
    for test in &mut tests {
      //grab artifact path from test vector
      let artifact_path_str = match test.pop() {
        Some(string) => string,
        None => {
          debug::print_debug("firmrebuild::on_test: invalid test vector");
          return TestStatus::Failed;
        }
      };
      let artifact_path = Path::new(artifact_path_str);

      //grab output path from test vector
      let output_path_str = match test.pop() {
        Some(string) => string,
        None => {
          debug::print_debug("firmrebuild::on_test: invalid test vector");
          return TestStatus::Failed;
        }
      };
      let output_path = Path::new(output_path_str);

      //run firmware extract in fmk_path
      let command = "./build-firmware.sh";
      let output = match Command::new(command).args(test).current_dir(fmk_path).output() {
        Ok(out) => out,
        Err(err) => {
          debug::print_debug(format!("firmrebuild::on_test: failed to execute firmrebuild. {}",err));
          return TestStatus::Failed;
        }
      };

      //make sure that firmextract returned with an exit code of 0
      let exit_status = match output.status.code() {
        Some(status) => status,
        None => {
          debug::print_debug("firmrebuild::on_test: failed to get firmrebuild exit code.");
          return TestStatus::Failed;
        }
      };
      if exit_status != 0 {
        debug::print_debug("firmrebuild::on_test: firmrebuild returned with a non-zero exit code");
        return TestStatus::Failed;
      }

      //read artifact file to byte vec
      let artifact_vec: Vec<u8> = match fs::read(artifact_path) {
        Ok(vec) => vec,
        Err(err) => {
          debug::print_debug(format!("firmrebuild::on_test: failed to read artifact file to byte vec {}",err));
          return TestStatus::Failed;
        }
      };

      //read output file to byte vec
      let output_vec: Vec<u8> = match fs::read(output_path) {
        Ok(vec) => vec,
        Err(err) => {
          debug::print_debug(format!("firmrebuild::on_test: failed to read output file to byte vec {}",err));
          return TestStatus::Failed;
        }
      };

      //compare the output file to the artifact file
      if artifact_vec.len() != output_vec.len() {
        debug::print_debug("firmrebuild::on_test: output vec len doesnt match artifact vec len.");
        return TestStatus::Failed;
      }
    }
    return TestStatus::Passed;
  }
  fn get_event(&self) -> &Event { return &self.event; }
}
pub fn firmrebuild(links: Vec<String>, name: String, parent: String) -> Box<dyn Eventable + Send + Sync> {
  Box::new(FirmRebuild {
    event: Event {
      name:   name,
      desc:   "Reconstructs firmware that has been extracted using firmware-extract.".to_string(),
      usage:  "Prompts you for: \
              \n\tPath to extracted firmware\n".to_string(),
      author: "github.com/rampageX".to_string(),
      easyrun: false,
      secure: false,
      parent: parent,
      links:  links
    }
  })
}


